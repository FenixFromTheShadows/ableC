# Embedded Domain Specific Languages
A common pattern in writing extensions, in addition to basic new host-like constructs, is to define embedded domain spesific languages (EDSLs) that are translated into the host language.  There are a number of applications of these, such as the expression of new types of computation (e.g. term rewriting), specifying transformations to perform on host code, or writting fragments of code in a subset of another language better suited for the task.  

The abstract and concrete syntax for an EDSL extension typically each introduce new nonterminals to represent the structure of the embedded language.  The new concrete syntax is rooted in a 'bridge production' from a host nonterminal, and uses the `ast` attribute to build the new abstract nonterminal.  The abstract syntax for the EDSL has a similar structure, with a bridge production (for ableC, usually on `Decl`, `Stmt` or `Expr`) that roots the syntax for the body of the EDSL.  Various attributes on the new abstract nonterminal are used to perform error-checking and compute the translation back into the host language, which are then used by the bridge production to either forward to an error production or to the resulting translation.  

## Example
A simple example of an EDSL is writing expressions in prefix form, and performing error checking explicitly.  In [concretesyntax/Prefix.sv](edu.umn.cs.melt.tutorials.ableC.prefixExpr/concretesyntax/Prefix.sv), a new concrete nonterminal `PrefixExpr_c` is introduced.  Note that this nonterminal is marked `closed`: This means that other extensions extending this one may introduce new nonforwarding productions, but no new attributes, which makes sense in the context of concrete syntax.  Typically all abstract nonterminals are open and all concrete nonterminals are closed, but there are some exception to this.  

The productions on `PrefixExpr_c` specify the new concrete syntax of this EDSL.  Note that no new terminals are used here - it is preferable to make new concrete syntax resemble the host syntax when doing so is an option.  This helps to make the transition from host code to extension code as seamless as possible, and also aids in passing the modular analysis for concrete syntax, which will be described later.  

The last production on `PrefixExpr_c` is referred to an 'escape hatch' production, allowing a transition back from extension to host syntax.  This sort of production often requires special syntax, such as wrapping expressions in double-parentheses or statements in double-braces, to avoid syntactic ambiguities.  This workaround was not required for this particular example, since the EDSL syntax does not include parentheses.  

The abstract syntax for this extension can be found in [abstractsyntax/Prefix.sv](edu.umn.cs.melt.tutorials.ableC.prefixExpr/abstractsyntax/Prefix.sv).  Here the new `PrefixExpr` nonterminal represents the abstract structure of the EDSL.  This is rooted in the production `prefixExpr` bridging between host and extension abstract syntax, which simply checks for errors on the EDSL and forwards to an error production or the `toExpr` computed translation to host.  

Note that since `PrefixExpr` may contain `Expr`s, `PrefixExpr` must somehow provide all the inherited attributes needed by `Expr`.  Typically, most of these inherited attributes will occur on the new nonterminal, and simply be copied down from the top-level.  However, there are some cases where 'dummy' values may be provided for some inherited attributes (such as `returnType`) in cases where there is no actual value possible.  
